<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªå¾‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ»ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ with AI</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            max-width: 250px;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.95);
            padding: 15px;
            border-radius: 8px;
            max-width: 280px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        #info-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #info-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        #info-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .panel-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 6px;
            margin: 6px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            font-size: 12px;
        }
        
        button {
            padding: 6px 12px;
            margin: 6px 0;
            cursor: pointer;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .agent-card {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        
        .agent-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .agent-name {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .agent-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .status-active {
            background: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .agent-info-row {
            margin: 3px 0;
            font-size: 12px;
            color: #b0b0b0;
        }
        
        .agent-thought {
            font-style: italic;
            color: #80cbc4;
            margin-top: 6px;
            padding: 6px;
            background: rgba(128, 203, 196, 0.1);
            border-radius: 4px;
            border-left: 3px solid #80cbc4;
            font-size: 12px;
        }
        
        .agent-memory {
            margin-top: 6px;
            font-size: 11px;
        }
        
        .memory-item {
            padding: 3px 6px;
            margin: 2px 0;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 3px;
            color: #888;
        }
        
        .relationship-info {
            margin-top: 6px;
            font-size: 11px;
        }
        
        .relationship-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 4px 0;
        }
        
        .relationship-bar {
            width: 100px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .relationship-fill {
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #ffd93d, #6bcf7f);
            transition: width 0.3s ease;
        }
        
        #log-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            padding: 12px;
            border-radius: 8px;
            max-width: 350px;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .log-entry {
            margin: 6px 0;
            padding: 6px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            font-size: 11px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-thought {
            border-left-color: #80cbc4;
            color: #80cbc4;
        }
        
        .log-interaction {
            border-left-color: #FFC107;
            color: #FFC107;
        }
        
        .log-movement {
            border-left-color: #2196F3;
            color: #2196F3;
        }
        
        .time-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.95);
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 13px;
            color: #4CAF50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .warning {
            color: #ff9800;
            font-size: 11px;
            margin-top: 8px;
            padding: 8px;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
        .thinking-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 1.5s infinite;
            margin-left: 8px;
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        .log-entry {
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 6px;
            font-size: 13px;
            border-left: 3px solid transparent;
            transition: all 0.3s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .log-thought {
            border-left-color: #80cbc4;
            color: #80cbc4;
        }
        
        .log-interaction {
            border-left-color: #FFC107;
            color: #FFC107;
        }
        
        .log-movement {
            border-left-color: #2196F3;
            color: #2196F3;
        }
        
        .log-relationship {
            border-left-color: #E91E63;
            color: #E91E63;
        }
        
        .log-details-toggle {
            margin-top: 5px;
            cursor: pointer;
            color: #888;
            font-size: 12px;
        }
        
        .log-details-toggle:hover {
            color: #fff;
        }
        
        .log-details {
            margin-top: 6px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 3px;
            font-size: 11px;
        }
        
        .log-detail-section {
            margin-bottom: 6px;
        }
        
        .log-detail-section h4 {
            margin: 0 0 4px 0;
            color: #4CAF50;
            font-size: 11px;
        }
        
        .agent-name {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .relationship-change {
            color: #E91E63;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="time-display" id="time-display">
        åˆå‰ 8:00
    </div>
    
    <div id="control-panel">
        <h3 class="panel-title">ğŸ”§ åˆ¶å¾¡ãƒ‘ãƒãƒ«</h3>
        <input type="password" id="apiKey" placeholder="OpenAI APIã‚­ãƒ¼ã‚’å…¥åŠ›">
        <button onclick="startSimulation()">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹</button>
        <button onclick="pauseSimulation()" id="pauseBtn" disabled>ä¸€æ™‚åœæ­¢</button>
        <button onclick="setTimeSpeed()">æ™‚é–“é€Ÿåº¦: <span id="speed">1x</span></button>
        <div class="warning">
            âš ï¸ APIã‚­ãƒ¼ã¯ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜ã•ã‚Œã¾ã›ã‚“ã€‚<br>
            å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼çµŒç”±ã§APIã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚
        </div>
    </div>
    
    <div id="info-panel">
        <h3 class="panel-title">ğŸ‘¥ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæƒ…å ±</h3>
        <div id="agents-list"></div>
    </div>
    
    <div id="log-panel">
        <h3 class="panel-title">ğŸ“ æ´»å‹•ãƒ­ã‚°</h3>
        <div id="activity-log"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let scene, camera, renderer;
        let agents = [];
        let locations = [];
        let apiKey = '';
        let simulationRunning = false;
        let simulationPaused = false;
        let timeSpeed = 1;
        let currentTime = 8 * 60; // 8:00 AM in minutes
        const clock = new THREE.Clock();
        
        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è©³ç´°ãªæ€§æ ¼è¨­å®š
        const agentPersonalities = [
            {
                name: "ç”°ä¸­å¤ªéƒ",
                age: 35,
                personality: {
                    description: "è¦ªåˆ‡ã§ç¤¾äº¤çš„ãªä¼šç¤¾å“¡ã€‚ã‚³ãƒ¼ãƒ’ãƒ¼ãŒå¥½ãã§ã€æœã¯ã‚«ãƒ•ã‚§ã§ä¸€æ—¥ã‚’å§‹ã‚ã‚‹ã€‚",
                    traits: {
                        sociability: 0.9,      // ç¤¾äº¤æ€§ï¼ˆ0-1ï¼‰
                        energy: 0.7,           // æ´»å‹•çš„ã•
                        routine: 0.8,          // ãƒ«ãƒ¼ãƒãƒ³é‡è¦–åº¦
                        curiosity: 0.6,        // å¥½å¥‡å¿ƒ
                        empathy: 0.9          // å…±æ„Ÿæ€§
                    }
                },
                color: 0x4CAF50,
                dailyRoutine: {
                    morning: ["ã‚«ãƒ•ã‚§", "ç”ºã®åºƒå ´"],
                    afternoon: ["å›³æ›¸é¤¨", "å…¬åœ’"],
                    evening: ["ã‚«ãƒ•ã‚§", "ç”ºã®åºƒå ´"],
                    night: ["è‡ªå®…"]
                },
                home: {
                    name: "ç”°ä¸­å¤ªéƒã®å®¶",
                    x: -15,
                    z: -15,
                    color: 0x4CAF50
                }
            },
            {
                name: "å±±ç”°èŠ±å­",
                age: 28,
                personality: {
                    description: "å‰µé€ çš„ãªã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆã€‚å…¬åœ’ã§çµµã‚’æãã®ãŒå¥½ãã€‚ç‹¬è‡ªã®ä¸–ç•Œè¦³ã‚’æŒã¤ã€‚",
                    traits: {
                        sociability: 0.5,
                        energy: 0.6,
                        routine: 0.3,
                        curiosity: 0.9,
                        empathy: 0.8
                    }
                },
                color: 0xFF6B6B,
                dailyRoutine: {
                    morning: ["å…¬åœ’"],
                    afternoon: ["å…¬åœ’", "ã‚«ãƒ•ã‚§"],
                    evening: ["å›³æ›¸é¤¨", "ç”ºã®åºƒå ´"],
                    night: ["è‡ªå®…"]
                },
                home: {
                    name: "å±±ç”°èŠ±å­ã®å®¶",
                    x: 15,
                    z: -15,
                    color: 0xFF6B6B
                }
            },
            {
                name: "ä½è—¤æ¬¡éƒ",
                age: 22,
                personality: {
                    description: "å†…å‘çš„ãªå¤§å­¦ç”Ÿã€‚å›³æ›¸é¤¨ã§å‹‰å¼·ã™ã‚‹ã“ã¨ãŒå¤šã„ã€‚æ–°ã—ã„çŸ¥è­˜ã‚’æ±‚ã‚ã¦ã„ã‚‹ã€‚",
                    traits: {
                        sociability: 0.3,
                        energy: 0.5,
                        routine: 0.7,
                        curiosity: 0.8,
                        empathy: 0.6
                    }
                },
                color: 0x4ECDC4,
                dailyRoutine: {
                    morning: ["å›³æ›¸é¤¨"],
                    afternoon: ["å›³æ›¸é¤¨", "ã‚«ãƒ•ã‚§"],
                    evening: ["ç”ºã®åºƒå ´", "å›³æ›¸é¤¨"],
                    night: ["è‡ªå®…"]
                },
                home: {
                    name: "ä½è—¤æ¬¡éƒã®å®¶",
                    x: -15,
                    z: 15,
                    color: 0x4ECDC4
                }
            },
            {
                name: "éˆ´æœ¨ç¾é¦™",
                age: 26,
                personality: {
                    description: "æ´»ç™ºã§ã‚¹ãƒãƒ¼ãƒ„å¥½ãã€‚æœã®ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°ãŒæ—¥èª²ã€‚äººã¨ã®äº¤æµã‚’æ¥½ã—ã‚€ã€‚",
                    traits: {
                        sociability: 0.8,
                        energy: 0.95,
                        routine: 0.9,
                        curiosity: 0.7,
                        empathy: 0.7
                    }
                },
                color: 0xFFE66D,
                dailyRoutine: {
                    morning: ["ã‚¹ãƒãƒ¼ãƒ„ã‚¸ãƒ ", "å…¬åœ’"],
                    afternoon: ["ã‚«ãƒ•ã‚§", "ç”ºã®åºƒå ´"],
                    evening: ["ã‚¹ãƒãƒ¼ãƒ„ã‚¸ãƒ ", "å…¬åœ’"],
                    night: ["è‡ªå®…"]
                },
                home: {
                    name: "éˆ´æœ¨ç¾é¦™ã®å®¶",
                    x: 15,
                    z: 15,
                    color: 0xFFE66D
                }
            },
            {
                name: "é«˜æ©‹å¥ä¸€",
                age: 65,
                personality: {
                    description: "ã®ã‚“ã³ã‚Šã—ãŸæ€§æ ¼ã®å¹´é…è€…ã€‚ã‚«ãƒ•ã‚§ã§ãã¤ã‚ãã€è‹¥ã„äººã¨ã®ä¼šè©±ã‚’æ¥½ã—ã‚€ã€‚",
                    traits: {
                        sociability: 0.7,
                        energy: 0.3,
                        routine: 0.9,
                        curiosity: 0.5,
                        empathy: 0.95
                    }
                },
                color: 0xA8E6CF,
                dailyRoutine: {
                    morning: ["ã‚«ãƒ•ã‚§", "ç”ºã®åºƒå ´"],
                    afternoon: ["å…¬åœ’", "ã‚«ãƒ•ã‚§"],
                    evening: ["ç”ºã®åºƒå ´", "ã‚«ãƒ•ã‚§"],
                    night: ["è‡ªå®…"]
                },
                home: {
                    name: "é«˜æ©‹å¥ä¸€ã®å®¶",
                    x: 0,
                    z: -20,
                    color: 0xA8E6CF
                }
            }
        ];
        
        // å ´æ‰€ã®è©³ç´°è¨­å®š
        const locationData = [
            {
                name: "ã‚«ãƒ•ã‚§",
                x: -10,
                z: -10,
                color: 0x8B4513,
                activities: ["ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’é£²ã‚€", "ä¼šè©±ã™ã‚‹", "èª­æ›¸ã™ã‚‹", "ä»•äº‹ã‚’ã™ã‚‹"],
                atmosphere: "è½ã¡ç€ã„ãŸé›°å›²æ°—ã§ã€ã‚³ãƒ¼ãƒ’ãƒ¼ã®é¦™ã‚ŠãŒæ¼‚ã†"
            },
            {
                name: "å…¬åœ’",
                x: 10,
                z: -10,
                color: 0x228B22,
                activities: ["æ•£æ­©ã™ã‚‹", "çµµã‚’æã", "ãƒ™ãƒ³ãƒã§ä¼‘ã‚€", "é‹å‹•ã™ã‚‹"],
                atmosphere: "ç·‘è±Šã‹ã§é–‹æ”¾çš„ãªç©ºé–“"
            },
            {
                name: "å›³æ›¸é¤¨",
                x: -10,
                z: 10,
                color: 0x4682B4,
                activities: ["å‹‰å¼·ã™ã‚‹", "æœ¬ã‚’èª­ã‚€", "èª¿ã¹ç‰©ã‚’ã™ã‚‹", "é™ã‹ã«éã”ã™"],
                atmosphere: "é™å¯‚ã«åŒ…ã¾ã‚ŒãŸçŸ¥è­˜ã®å®åº«"
            },
            {
                name: "ã‚¹ãƒãƒ¼ãƒ„ã‚¸ãƒ ",
                x: 10,
                z: 10,
                color: 0xFF6347,
                activities: ["é‹å‹•ã™ã‚‹", "ç­‹ãƒˆãƒ¬ã™ã‚‹", "ãƒ¨ã‚¬ã‚’ã™ã‚‹", "ä»–ã®äººã¨é‹å‹•ã®è©±ã‚’ã™ã‚‹"],
                atmosphere: "æ´»æ°—ãŒã‚ã‚Šã€ã‚¨ãƒãƒ«ã‚®ãƒƒã‚·ãƒ¥ãªå ´æ‰€"
            },
            {
                name: "ç”ºã®åºƒå ´",
                x: 0,
                z: 0,
                color: 0xDAA520,
                activities: ["äººã€…ã‚’è¦³å¯Ÿã™ã‚‹", "å¾…ã¡åˆã‚ã›ã™ã‚‹", "ã‚¤ãƒ™ãƒ³ãƒˆã«å‚åŠ ã™ã‚‹", "ä¼‘æ†©ã™ã‚‹"],
                atmosphere: "ç”ºã®ä¸­å¿ƒã§ã€æ§˜ã€…ãªäººãŒè¡Œãäº¤ã†"
            }
        ];
        
        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¯ãƒ©ã‚¹ï¼ˆæ‹¡å¼µç‰ˆï¼‰
        class Agent {
            constructor(data, index) {
                this.name = data.name;
                this.age = data.age;
                this.personality = data.personality;
                this.dailyRoutine = data.dailyRoutine;
                this.currentLocation = locations[index % locations.length];
                this.targetLocation = this.currentLocation;
                
                // è¨˜æ†¶ã‚·ã‚¹ãƒ†ãƒ 
                this.shortTermMemory = [];  // çŸ­æœŸè¨˜æ†¶ï¼ˆæœ€è¿‘ã®å‡ºæ¥äº‹ï¼‰
                this.longTermMemory = [];   // é•·æœŸè¨˜æ†¶ï¼ˆé‡è¦ãªå‡ºæ¥äº‹ï¼‰
                this.relationships = new Map(); // ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®é–¢ä¿‚æ€§
                
                // ç¾åœ¨ã®çŠ¶æ…‹
                this.currentThought = "ä¸€æ—¥ã‚’å§‹ã‚ã¦ã„ã¾ã™...";
                this.currentActivity = null;
                this.mood = "æ™®é€š";
                this.energy = 1.0;
                this.isThinking = false;
                
                // ã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ¶å¾¡
                this.lastActionTime = Date.now();
                this.lastThoughtTime = Date.now();
                this.thinkingDuration = 5000 + Math.random() * 10000; // 5-15ç§’
                
                // 3Dãƒ¢ãƒ‡ãƒ«
                this.createModel(data.color);
                
                // ç§»å‹•é–¢é€£
                this.speed = 0.03 + (this.personality.traits.energy * 0.02);
                this.movementTarget = null;
                
                // ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®é–¢ä¿‚ã‚’åˆæœŸåŒ–
                this.initializeRelationships();
            }
            
            createModel(color) {
                const group = new THREE.Group();
                
                // ä½“ï¼ˆå††æŸ±ï¼‰
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
                bodyMesh.position.y = 0.5;
                bodyMesh.castShadow = true;
                group.add(bodyMesh);
                
                // é ­ï¼ˆçƒä½“ï¼‰
                const headGeometry = new THREE.SphereGeometry(0.25, 8, 8);
                const headMaterial = new THREE.MeshLambertMaterial({ color: color });
                const headMesh = new THREE.Mesh(headGeometry, headMaterial);
                headMesh.position.y = 1.25;
                headMesh.castShadow = true;
                group.add(headMesh);
                
                // æ€è€ƒä¸­ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ï¼ˆé ­ã®ä¸Šã®å°ã•ãªçƒï¼‰
                const thinkingGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const thinkingMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.5
                });
                this.thinkingIndicator = new THREE.Mesh(thinkingGeometry, thinkingMaterial);
                this.thinkingIndicator.position.y = 1.8;
                this.thinkingIndicator.visible = false;
                group.add(this.thinkingIndicator);
                
                this.mesh = group;
                this.mesh.position.copy(this.currentLocation.position);
                this.mesh.position.y = 0;
                scene.add(this.mesh);
            }
            
            initializeRelationships() {
                // ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®åˆæœŸé–¢ä¿‚å€¤ã‚’è¨­å®š
                agentPersonalities.forEach(other => {
                    if (other.name !== this.name) {
                        this.relationships.set(other.name, {
                            familiarity: Math.random() * 0.3, // 0-0.3ã®åˆæœŸå€¤
                            affinity: 0.5, // ä¸­ç«‹çš„ãªé–¢ä¿‚ã‹ã‚‰é–‹å§‹
                            lastInteraction: null,
                            interactionCount: 0
                        });
                    }
                });
            }
            
            async update(deltaTime) {
                // ã‚¨ãƒãƒ«ã‚®ãƒ¼ã®æ›´æ–°ï¼ˆæ™‚é–“ã¨ã¨ã‚‚ã«æ¸›å°‘ï¼‰
                this.energy = Math.max(0.1, this.energy - (deltaTime * 0.0001));
                
                // å¤œé–“ã¯è‡ªå®…ã§ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’å›å¾©
                if (this.getTimeOfDay() === "night" && this.currentLocation.name === this.home.name) {
                    this.energy = Math.min(1.0, this.energy + (deltaTime * 0.0002));
                }
                
                // ç§»å‹•å‡¦ç†
                if (this.movementTarget) {
                    const direction = new THREE.Vector3()
                        .subVectors(this.movementTarget, this.mesh.position)
                        .normalize();
                    
                    const distance = this.mesh.position.distanceTo(this.movementTarget);
                    
                    if (distance > 0.5) {
                        const currentSpeed = this.speed * this.energy;
                        this.mesh.position.add(direction.multiplyScalar(currentSpeed));
                        this.mesh.position.y = 0;
                    } else if (this.targetLocation) {
                        // ç›®çš„åœ°ã«åˆ°ç€
                        this.currentLocation = this.targetLocation;
                        this.movementTarget = null;
                        this.onArrival();
                    }
                }
                
                // æ€è€ƒä¸­ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.isThinking && this.thinkingIndicator) {
                    this.thinkingIndicator.visible = true;
                    this.thinkingIndicator.position.y = 1.8 + Math.sin(Date.now() * 0.003) * 0.1;
                    this.thinkingIndicator.rotation.y += deltaTime * 2;
                } else {
                    this.thinkingIndicator.visible = false;
                }
                
                // å®šæœŸçš„ãªæ€è€ƒãƒ—ãƒ­ã‚»ã‚¹
                if (Date.now() - this.lastThoughtTime > this.thinkingDuration && !this.isThinking) {
                    this.think();
                }
            }
            
            async think() {
                if (!apiKey || !simulationRunning || simulationPaused) return;
                
                this.isThinking = true;
                const timeOfDay = this.getTimeOfDay();
                const nearbyAgents = this.getNearbyAgents();
                
                try {
                    // æ€è€ƒãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
                    const prompt = this.buildThoughtPrompt(timeOfDay, nearbyAgents);
                    
                    // ãƒ‡ãƒ¢ç”¨ã®æ€è€ƒã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®APIå‘¼ã³å‡ºã—ã®ä»£ã‚ã‚Šï¼‰
                    const decision = await this.simulateThought(prompt, timeOfDay, nearbyAgents);
                    
                    // æ±ºå®šã«åŸºã¥ã„ã¦è¡Œå‹•
                    this.executeDecision(decision);
                    
                    logAgentAction(this, 'think', `
                        <div class="log-detail-section">
                            <h4>æ€è€ƒã®è©³ç´°</h4>
                            <p>æ™‚é–“å¸¯: ${timeOfDay}</p>
                            <p>å ´æ‰€: ${this.currentLocation.name}</p>
                            <p>è¿‘ãã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ: ${nearbyAgents.map(a => a.name).join(', ') || 'ãªã—'}</p>
                            <p>æ€è€ƒå†…å®¹: ${this.currentThought}</p>
                        </div>
                    `);
                    
                } catch (error) {
                    console.error(`${this.name}ã®æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼:`, error);
                } finally {
                    this.isThinking = false;
                    this.lastThoughtTime = Date.now();
                    this.thinkingDuration = 10000 + Math.random() * 20000; // 10-30ç§’
                }
            }
            
            buildThoughtPrompt(timeOfDay, nearbyAgents) {
                const recentMemories = this.shortTermMemory.slice(-5).map(m => m.event).join(', ');
                const currentMood = this.calculateMood();
                
                return `
                ç§ã¯${this.name}ã€${this.age}æ­³ã€‚${this.personality.description}
                
                ç¾åœ¨ã®çŠ¶æ³:
                - æ™‚é–“å¸¯: ${timeOfDay}ï¼ˆå¤œé–“ã¯22:00-6:00ï¼‰
                - ç¾åœ¨åœ°: ${this.currentLocation.name}ï¼ˆ${this.currentLocation.atmosphere}ï¼‰
                - ä½“åŠ›: ${Math.round(this.energy * 100)}%
                - æ°—åˆ†: ${currentMood}
                - æœ€è¿‘ã®å‡ºæ¥äº‹: ${recentMemories || 'ãªã—'}
                
                ${nearbyAgents.length > 0 ? `è¿‘ãã«ã„ã‚‹äºº: ${nearbyAgents.map(a => a.name).join(', ')}` : ''}
                
                ç§ã®æ€§æ ¼ç‰¹æ€§:
                - ç¤¾äº¤æ€§: ${this.personality.traits.sociability}
                - æ´»å‹•çš„ã•: ${this.personality.traits.energy}
                - ãƒ«ãƒ¼ãƒãƒ³é‡è¦–: ${this.personality.traits.routine}
                - å¥½å¥‡å¿ƒ: ${this.personality.traits.curiosity}
                
                é‡è¦ãªè¡Œå‹•ãƒ«ãƒ¼ãƒ«:
                1. å¤œé–“ï¼ˆ22:00-6:00ï¼‰ã¯å¿…ãšè‡ªå®…ã«å¸°ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™
                2. å¤œé–“ã¯è‡ªå®…ä»¥å¤–ã®å ´æ‰€ã«é•·ãç•™ã¾ã‚‰ãªã„ã§ãã ã•ã„
                3. å¤œé–“ã¯ä½“åŠ›ã‚’å›å¾©ã™ã‚‹ãŸã‚ã«è‡ªå®…ã§ä¼‘ã‚€ã“ã¨ãŒé‡è¦ã§ã™
                
                ã“ã®çŠ¶æ³ã§ã€æ¬¡ã«ä½•ã‚’ã—ãŸã„ã§ã™ã‹ï¼Ÿã©ã®ã‚ˆã†ã«æ„Ÿã˜ã¦ã„ã¾ã™ã‹ï¼Ÿ
                ç‰¹ã«å¤œé–“ã®å ´åˆã¯ã€è‡ªå®…ã«å¸°ã‚‹ã“ã¨ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚
                `;
            }
            
            async simulateThought(prompt, timeOfDay, nearbyAgents) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo",
                            messages: [
                                {
                                    role: "system",
                                    content: "ã‚ãªãŸã¯è‡ªå¾‹çš„ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ„æ€æ±ºå®šã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸçŠ¶æ³ã«åŸºã¥ã„ã¦ã€è‡ªç„¶ãªè¡Œå‹•ã¨æ€è€ƒã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚ç‰¹ã«å¤œé–“ï¼ˆ22:00-6:00ï¼‰ã¯å¿…ãšè‡ªå®…ã«å¸°ã‚‹ã“ã¨ã‚’å„ªå…ˆã—ã¦ãã ã•ã„ã€‚"
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 150
                        })
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error?.message || 'APIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }

                    const aiResponse = data.choices[0].message.content;
                    
                    // AIã®å¿œç­”ã‚’è§£æã—ã¦æ±ºå®šã‚’ç”Ÿæˆ
                    const decision = {
                        action: null,
                        thought: aiResponse,
                        targetLocation: null,
                        targetAgent: null
                    };

                    // å¤œé–“ã®å ´åˆã¯å¿…ãšè‡ªå®…ã«å¸°ã‚‹
                    if (timeOfDay === "night" && this.currentLocation.name !== this.home.name) {
                        const homeLocation = locations.find(l => l.name === this.home.name);
                        if (homeLocation) {
                            decision.action = "move";
                            decision.targetLocation = homeLocation;
                            decision.thought = "å¤œã«ãªã£ãŸã®ã§ã€è‡ªå®…ã«å¸°ã‚Šã¾ã™ã€‚";
                            return decision;
                        }
                    }

                    // æ™‚é–“å¸¯ã«åŸºã¥ããƒ«ãƒ¼ãƒãƒ³ã®ç¢ºèª
                    const routineLocation = this.getRoutineLocation(timeOfDay);
                    const shouldFollowRoutine = Math.random() < this.personality.traits.routine;

                    // ç¤¾äº¤çš„ãªè¡Œå‹•ã®æ±ºå®š
                    if (nearbyAgents.length > 0 && Math.random() < this.personality.traits.sociability) {
                        const targetAgent = nearbyAgents[Math.floor(Math.random() * nearbyAgents.length)];
                        const relationship = this.relationships.get(targetAgent.name);
                        
                        if (relationship && relationship.affinity > 0.3) {
                            decision.action = "interact";
                            decision.targetAgent = targetAgent;
                        }
                    }

                    // ç§»å‹•ã®æ±ºå®š
                    if (!decision.action) {
                        if (shouldFollowRoutine && routineLocation && routineLocation !== this.currentLocation.name) {
                            const targetLoc = locations.find(l => l.name === routineLocation);
                            if (targetLoc) {
                                decision.action = "move";
                                decision.targetLocation = targetLoc;
                            }
                        } else if (Math.random() < this.personality.traits.curiosity) {
                            const randomLocation = locations[Math.floor(Math.random() * locations.length)];
                            if (randomLocation !== this.currentLocation) {
                                decision.action = "move";
                                decision.targetLocation = randomLocation;
                            }
                        }
                    }

                    // ç¾åœ¨åœ°ã§ã®æ´»å‹•
                    if (!decision.action && this.currentLocation.activities.length > 0) {
                        const activity = this.currentLocation.activities[
                            Math.floor(Math.random() * this.currentLocation.activities.length)
                        ];
                        decision.action = "activity";
                        this.currentActivity = activity;
                    }

                    return decision;

                } catch (error) {
                    console.error('OpenAI APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
                    return {
                        action: null,
                        thought: "è€ƒãˆä¸­...",
                        targetLocation: null,
                        targetAgent: null
                    };
                }
            }
            
            executeDecision(decision) {
                this.currentThought = decision.thought;
                
                // æ€è€ƒã‚’ãƒ­ã‚°ã«è¿½åŠ 
                addLog(decision.thought, 'thought');
                
                // è¨˜æ†¶ã«è¿½åŠ 
                this.addMemory(decision.thought, "thought");
                
                switch (decision.action) {
                    case "move":
                        if (decision.targetLocation) {
                            this.moveToLocation(decision.targetLocation);
                        }
                        break;
                    
                    case "interact":
                        if (decision.targetAgent) {
                            this.interactWith(decision.targetAgent);
                        }
                        break;
                    
                    case "activity":
                        this.performActivity();
                        break;
                }
            }
            
            moveToLocation(location) {
                this.targetLocation = location;
                this.movementTarget = new THREE.Vector3(
                    location.position.x + (Math.random() - 0.5) * 2,
                    0,
                    location.position.z + (Math.random() - 0.5) * 2
                );
                
                addLog(`ğŸš¶ ${this.name}ãŒ${location.name}ã¸ç§»å‹•é–‹å§‹`, 'move', `
                    <div class="log-detail-section">
                        <h4>ç§»å‹•ã®è©³ç´°</h4>
                        <p>å‡ºç™ºåœ°: ${this.currentLocation.name}</p>
                        <p>ç›®çš„åœ°: ${location.name}</p>
                        <p>ç§»å‹•é€Ÿåº¦: ${this.speed.toFixed(2)}</p>
                    </div>
                `);
            }
            
            onArrival() {
                addLog(`ğŸ“ ${this.name}ãŒ${this.currentLocation.name}ã«åˆ°ç€`, 'arrival');
                
                // åˆ°ç€æ™‚ã®æ´»å‹•ã‚’æ±ºå®š
                if (this.currentLocation.activities.length > 0) {
                    const activity = this.currentLocation.activities[
                        Math.floor(Math.random() * this.currentLocation.activities.length)
                    ];
                    this.currentActivity = activity;
                    this.currentThought = `${activity}ã“ã¨ã«ã—ã‚ˆã†`;
                }
            }
            
            interactWith(otherAgent) {
                const relationship = this.relationships.get(otherAgent.name);
                if (!relationship) return;
                
                // ç›¸äº’ä½œç”¨ã®ç¨®é¡ã‚’æ±ºå®š
                const interactionTypes = this.getInteractionTypes(relationship);
                const interaction = interactionTypes[Math.floor(Math.random() * interactionTypes.length)];
                
                // ç›¸äº’ä½œç”¨ã‚’å®Ÿè¡Œ
                this.performInteraction(otherAgent, interaction);
                
                // é–¢ä¿‚æ€§ã®æ›´æ–°
                const oldAffinity = relationship.affinity;
                relationship.familiarity = Math.min(1, relationship.familiarity + 0.1);
                relationship.affinity = Math.min(1, Math.max(0, relationship.affinity + (Math.random() - 0.3) * 0.2));
                
                if (Math.abs(relationship.affinity - oldAffinity) > 0.1) {
                    logRelationshipChange(this, otherAgent, 'interaction');
                }
                
                relationship.lastInteraction = new Date();
                relationship.interactionCount++;
                
                // ç›¸æ‰‹å´ã®é–¢ä¿‚æ€§ã‚‚æ›´æ–°
                const otherRelationship = otherAgent.relationships.get(this.name);
                if (otherRelationship) {
                    otherRelationship.familiarity = relationship.familiarity;
                    otherRelationship.affinity = relationship.affinity;
                    otherRelationship.lastInteraction = relationship.lastInteraction;
                    otherRelationship.interactionCount++;
                }
            }
            
            getInteractionTypes(relationship) {
                const types = [];
                
                if (relationship.familiarity < 0.3) {
                    types.push("æŒ¨æ‹¶", "è‡ªå·±ç´¹ä»‹", "å¤©æ°—ã®è©±");
                } else if (relationship.familiarity < 0.7) {
                    types.push("é›‘è«‡", "è¿‘æ³å ±å‘Š", "å…±é€šã®è©±é¡Œ");
                } else {
                    types.push("æ·±ã„ä¼šè©±", "ç›¸è«‡", "ä¸€ç·’ã«æ´»å‹•");
                }
                
                if (relationship.affinity > 0.7) {
                    types.push("å†—è«‡", "æ€ã„å‡ºè©±");
                } else if (relationship.affinity < 0.3) {
                    types.push("çŸ­ã„ä¼šè©±", "å½¢å¼çš„ãªæŒ¨æ‹¶");
                }
                
                return types;
            }
            
            async performInteraction(otherAgent, interactionType) {
                try {
                    const prompt = `
                    ã‚ãªãŸã¯${this.name}ã¨ã„ã†${this.age}æ­³ã®${this.personality.description}ã§ã™ã€‚
                    ç¾åœ¨${this.currentLocation.name}ã«ã„ã¦ã€${otherAgent.name}ã•ã‚“ã¨${interactionType}ã‚’ã—ã¦ã„ã¾ã™ã€‚
                    
                    ã‚ãªãŸã®æ€§æ ¼ç‰¹æ€§:
                    - ç¤¾äº¤æ€§: ${this.personality.traits.sociability}
                    - æ´»å‹•çš„ã•: ${this.personality.traits.energy}
                    - ãƒ«ãƒ¼ãƒãƒ³é‡è¦–: ${this.personality.traits.routine}
                    - å¥½å¥‡å¿ƒ: ${this.personality.traits.curiosity}
                    - å…±æ„Ÿæ€§: ${this.personality.traits.empathy}
                    
                    ç›¸æ‰‹ã¨ã®é–¢ä¿‚:
                    - è¦ªå¯†åº¦: ${this.relationships.get(otherAgent.name).familiarity}
                    - å¥½æ„Ÿåº¦: ${this.relationships.get(otherAgent.name).affinity}
                    
                    ã“ã®çŠ¶æ³ã§ã€è‡ªç„¶ãªä¼šè©±ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚1-2æ–‡ç¨‹åº¦ã®çŸ­ã„ä¼šè©±ã«ã—ã¦ãã ã•ã„ã€‚
                    `;

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo",
                            messages: [
                                {
                                    role: "system",
                                    content: "ã‚ãªãŸã¯è‡ªå¾‹çš„ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ä¼šè©±ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸçŠ¶æ³ã«åŸºã¥ã„ã¦ã€è‡ªç„¶ãªä¼šè©±ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚"
                                },
                                {
                                    role: "user",
                                    content: prompt
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 100
                        })
                    });

                    const data = await response.json();
                    if (!response.ok) {
                        throw new Error(data.error?.message || 'APIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }

                    const message = data.choices[0].message.content;
                    
                    this.currentThought = message;
                    addLog(`ğŸ’¬ ${this.name} â†’ ${otherAgent.name}: "${message}"`, 'interaction');
                    
                    this.addMemory(`${otherAgent.name}ã¨${interactionType}ã‚’ã—ãŸ`, "interaction");
                    
                    // ç›¸æ‰‹ã®åå¿œ
                    setTimeout(async () => {
                        if (otherAgent && !otherAgent.isThinking) {
                            const responsePrompt = `
                            ã‚ãªãŸã¯${otherAgent.name}ã¨ã„ã†${otherAgent.age}æ­³ã®${otherAgent.personality.description}ã§ã™ã€‚
                            ${this.name}ã•ã‚“ã‹ã‚‰ã€Œ${message}ã€ã¨è¨€ã‚ã‚Œã¾ã—ãŸã€‚
                            
                            ã‚ãªãŸã®æ€§æ ¼ç‰¹æ€§:
                            - ç¤¾äº¤æ€§: ${otherAgent.personality.traits.sociability}
                            - æ´»å‹•çš„ã•: ${otherAgent.personality.traits.energy}
                            - ãƒ«ãƒ¼ãƒãƒ³é‡è¦–: ${otherAgent.personality.traits.routine}
                            - å¥½å¥‡å¿ƒ: ${otherAgent.personality.traits.curiosity}
                            - å…±æ„Ÿæ€§: ${otherAgent.personality.traits.empathy}
                            
                            ç›¸æ‰‹ã¨ã®é–¢ä¿‚:
                            - è¦ªå¯†åº¦: ${otherAgent.relationships.get(this.name).familiarity}
                            - å¥½æ„Ÿåº¦: ${otherAgent.relationships.get(this.name).affinity}
                            
                            ã“ã®çŠ¶æ³ã§ã€è‡ªç„¶ãªè¿”ç­”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚1-2æ–‡ç¨‹åº¦ã®çŸ­ã„è¿”ç­”ã«ã—ã¦ãã ã•ã„ã€‚
                            `;

                            try {
                                const responseResponse = await fetch('https://api.openai.com/v1/chat/completions', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${apiKey}`
                                    },
                                    body: JSON.stringify({
                                        model: "gpt-3.5-turbo",
                                        messages: [
                                            {
                                                role: "system",
                                                content: "ã‚ãªãŸã¯è‡ªå¾‹çš„ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ä¼šè©±ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸçŠ¶æ³ã«åŸºã¥ã„ã¦ã€è‡ªç„¶ãªè¿”ç­”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚"
                                            },
                                            {
                                                role: "user",
                                                content: responsePrompt
                                            }
                                        ],
                                        temperature: 0.7,
                                        max_tokens: 100
                                    })
                                });

                                const responseData = await responseResponse.json();
                                if (!responseResponse.ok) {
                                    throw new Error(responseData.error?.message || 'APIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                                }

                                const responseMessage = responseData.choices[0].message.content;
                                otherAgent.currentThought = responseMessage;
                                addLog(`ğŸ’¬ ${otherAgent.name} â†’ ${this.name}: "${responseMessage}"`, 'interaction');
                            } catch (error) {
                                console.error('OpenAI APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼:', error);
                                const fallbackResponses = [
                                    `${this.name}ã•ã‚“ã€ç§ã‚‚åŒã˜ã‚ˆã†ã«æ€ã„ã¾ã™ï¼`,
                                    "ãªã‚‹ã»ã©ã€ãã†ã§ã™ã­ã€‚",
                                    "ãã‚Œã¯èˆˆå‘³æ·±ã„è©±ã§ã™ã­ã€‚",
                                    `${this.name}ã•ã‚“ã¨ãŠè©±ã—ã§ãã¦å¬‰ã—ã„ã§ã™ã€‚`
                                ];
                                const fallbackResponse = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
                                otherAgent.currentThought = fallbackResponse;
                                addLog(`ğŸ’¬ ${otherAgent.name} â†’ ${this.name}: "${fallbackResponse}"`, 'interaction');
                            }
                        }
                    }, 2000);
                } catch (error) {
                    console.error('OpenAI APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼:', error);
                    const fallbackMessages = {
                        "æŒ¨æ‹¶": [
                            `${otherAgent.name}ã•ã‚“ã€ã“ã‚“ã«ã¡ã¯ï¼`,
                            `ã‚„ã‚ã€${otherAgent.name}ã•ã‚“ã€‚å…ƒæ°—ï¼Ÿ`,
                            `${otherAgent.name}ã•ã‚“ã€ãŠä¹…ã—ã¶ã‚Šï¼`
                        ],
                        "è‡ªå·±ç´¹ä»‹": [
                            `åˆã‚ã¾ã—ã¦ã€${this.name}ã¨ç”³ã—ã¾ã™ã€‚`,
                            `${this.personality.description.split('ã€‚')[0]}ã§ã™ã€‚`,
                            `ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ï¼`
                        ],
                        "å¤©æ°—ã®è©±": [
                            "ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™ã­ã€‚",
                            "æœ€è¿‘ã€éã”ã—ã‚„ã™ã„æ°—å€™ã§ã™ã­ã€‚",
                            "ã“ã‚“ãªæ—¥ã¯å¤–ã«ã„ã‚‹ã¨æ°—æŒã¡ã„ã„ã§ã™ã­ã€‚"
                        ]
                    };
                    
                    const messageList = fallbackMessages[interactionType] || ["..."];
                    const message = messageList[Math.floor(Math.random() * messageList.length)];
                    
                    this.currentThought = message;
                    addLog(`ğŸ’¬ ${this.name} â†’ ${otherAgent.name}: "${message}"`, 'interaction');
                }
            }
            
            async performActivity() {
                if (this.currentActivity) {
                    try {
                        const prompt = `
                        ã‚ãªãŸã¯${this.name}ã¨ã„ã†${this.age}æ­³ã®${this.personality.description}ã§ã™ã€‚
                        ç¾åœ¨${this.currentLocation.name}ã§${this.currentActivity}ã—ã¦ã„ã¾ã™ã€‚
                        
                        ã‚ãªãŸã®æ€§æ ¼ç‰¹æ€§:
                        - ç¤¾äº¤æ€§: ${this.personality.traits.sociability}
                        - æ´»å‹•çš„ã•: ${this.personality.traits.energy}
                        - ãƒ«ãƒ¼ãƒãƒ³é‡è¦–: ${this.personality.traits.routine}
                        - å¥½å¥‡å¿ƒ: ${this.personality.traits.curiosity}
                        - å…±æ„Ÿæ€§: ${this.personality.traits.empathy}
                        
                        ã“ã®çŠ¶æ³ã§ã€ã‚ãªãŸãŒæ„Ÿã˜ã¦ã„ã‚‹ã“ã¨ã‚„è€ƒãˆã¦ã„ã‚‹ã“ã¨ã‚’è‡ªç„¶ãªå½¢ã§è¡¨ç¾ã—ã¦ãã ã•ã„ã€‚
                        1-2æ–‡ç¨‹åº¦ã®çŸ­ã„æ€è€ƒã«ã—ã¦ãã ã•ã„ã€‚
                        `;

                        const response = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: "gpt-3.5-turbo",
                                messages: [
                                    {
                                        role: "system",
                                        content: "ã‚ãªãŸã¯è‡ªå¾‹çš„ãªã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ€è€ƒã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚ä¸ãˆã‚‰ã‚ŒãŸçŠ¶æ³ã«åŸºã¥ã„ã¦ã€è‡ªç„¶ãªæ€è€ƒã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚"
                                    },
                                    {
                                        role: "user",
                                        content: prompt
                                    }
                                ],
                                temperature: 0.7,
                                max_tokens: 100
                            })
                        });

                        const data = await response.json();
                        if (!response.ok) {
                            throw new Error(data.error?.message || 'APIå‘¼ã³å‡ºã—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                        }

                        const thought = data.choices[0].message.content;
                        this.currentThought = thought;
                        addLog(`ğŸ¯ ${this.name}ã¯${this.currentLocation.name}ã§${this.currentActivity}ã„ã‚‹: "${thought}"`, 'activity', `
                            <div class="log-detail-section">
                                <h4>æ´»å‹•ã®è©³ç´°</h4>
                                <p>å ´æ‰€: ${this.currentLocation.name}</p>
                                <p>æ´»å‹•: ${this.currentActivity}</p>
                                <p>æ€è€ƒ: ${this.currentThought}</p>
                            </div>
                        `);
                        this.addMemory(`${this.currentLocation.name}ã§${this.currentActivity}`, "activity");
                    } catch (error) {
                        console.error('OpenAI APIå‘¼ã³å‡ºã—ã‚¨ãƒ©ãƒ¼:', error);
                        this.currentThought = `${this.currentActivity}ã„ã‚‹`;
                        addLog(`ğŸ¯ ${this.name}ã¯${this.currentLocation.name}ã§${this.currentActivity}ã„ã‚‹`, 'activity');
                        this.addMemory(`${this.currentLocation.name}ã§${this.currentActivity}`, "activity");
                    }
                }
            }
            
            addMemory(event, type) {
                const memory = {
                    time: new Date(),
                    event: event,
                    type: type,
                    location: this.currentLocation.name,
                    mood: this.mood
                };
                
                this.shortTermMemory.push(memory);
                
                // çŸ­æœŸè¨˜æ†¶ã®åˆ¶é™ï¼ˆæœ€æ–°20ä»¶ï¼‰
                if (this.shortTermMemory.length > 20) {
                    const oldMemory = this.shortTermMemory.shift();
                    // é‡è¦ãªè¨˜æ†¶ã¯é•·æœŸè¨˜æ†¶ã¸
                    if (oldMemory.type === "interaction" || Math.random() < 0.3) {
                        this.longTermMemory.push(oldMemory);
                    }
                }
                
                // é•·æœŸè¨˜æ†¶ã®åˆ¶é™ï¼ˆæœ€å¤§50ä»¶ï¼‰
                if (this.longTermMemory.length > 50) {
                    this.longTermMemory.shift();
                }
            }
            
            getNearbyAgents() {
                return agents.filter(agent => 
                    agent !== this && 
                    agent.currentLocation === this.currentLocation &&
                    this.mesh.position.distanceTo(agent.mesh.position) < 5
                );
            }
            
            getTimeOfDay() {
                const hour = Math.floor(currentTime / 60);
                if (hour < 6 || hour >= 22) return "night";
                if (hour < 12) return "morning";
                if (hour < 18) return "afternoon";
                return "evening";
            }
            
            getRoutineLocation(timeOfDay) {
                const routine = this.dailyRoutine[timeOfDay];
                if (routine && routine.length > 0) {
                    // å¤œé–“ã¯å¿…ãšè‡ªå®…ã«å¸°ã‚‹
                    if (timeOfDay === "night") {
                        return this.home.name;
                    }
                    return routine[Math.floor(Math.random() * routine.length)];
                }
                return null;
            }
            
            calculateMood() {
                if (this.energy < 0.3) return "ç–²ã‚Œã¦ã„ã‚‹";
                if (this.energy > 0.8) return "å…ƒæ°—";
                
                const recentInteractions = this.shortTermMemory.filter(m => 
                    m.type === "interaction" && 
                    (new Date() - m.time) < 300000 // 5åˆ†ä»¥å†…
                ).length;
                
                if (recentInteractions > 2) return "ç¤¾äº¤çš„";
                if (recentInteractions === 0 && this.personality.traits.sociability > 0.7) return "å¯‚ã—ã„";
                
                return "æ™®é€š";
            }
        }
        
        // Three.jsã®åˆæœŸåŒ–
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            //scene.fog = new THREE.Fog(0x87CEEB, 30, 60);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 35);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // åœ°é¢
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                emissive: 0x90EE90,
                emissiveIntensity: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
                        
            // å ´æ‰€ã®ä½œæˆ
            createLocations();
            
            // ãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            setupMouseControls();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
            animate();
        }
        
        // å ´æ‰€ã®ä½œæˆ
        function createLocations() {
            locationData.forEach(loc => {
                const locationGroup = new THREE.Group();
                
                // å»ºç‰©ã®åŸºæœ¬æ§‹é€ 
                const buildingGeometry = new THREE.BoxGeometry(6, 4, 6);
                const buildingMaterial = new THREE.MeshLambertMaterial({ 
                    color: loc.color,
                    emissive: loc.color,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.set(0, 2, 0);
                building.castShadow = true;
                building.receiveShadow = true;
                locationGroup.add(building);

                // å±‹æ ¹
                const roofGeometry = new THREE.ConeGeometry(4.5, 2, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    emissive: 0x8B4513,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 5, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                locationGroup.add(roof);

                // å ´æ‰€ç‰¹æœ‰ã®è£…é£¾
                switch(loc.name) {
                    case "ã‚«ãƒ•ã‚§":
                        // ãƒ†ãƒ¼ãƒ–ãƒ«ã¨æ¤…å­
                        for(let i = 0; i < 4; i++) {
                            const tableGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
                            const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const table = new THREE.Mesh(tableGeometry, tableMaterial);
                            table.position.set(
                                Math.cos(i * Math.PI/2) * 2,
                                0.05,
                                Math.sin(i * Math.PI/2) * 2
                            );
                            locationGroup.add(table);

                            // æ¤…å­
                            const chairGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                            const chairMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const chair = new THREE.Mesh(chairGeometry, chairMaterial);
                            chair.position.set(
                                Math.cos(i * Math.PI/2) * 2.5,
                                0.2,
                                Math.sin(i * Math.PI/2) * 2.5
                            );
                            locationGroup.add(chair);
                        }
                        break;

                    case "å…¬åœ’":
                        // æœ¨
                        for(let i = 0; i < 3; i++) {
                            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
                            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                            trunk.position.set(
                                Math.cos(i * Math.PI/1.5) * 2,
                                0.75,
                                Math.sin(i * Math.PI/1.5) * 2
                            );
                            locationGroup.add(trunk);

                            const leavesGeometry = new THREE.SphereGeometry(1, 8, 8);
                            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                            leaves.position.set(
                                Math.cos(i * Math.PI/1.5) * 2,
                                2,
                                Math.sin(i * Math.PI/1.5) * 2
                            );
                            locationGroup.add(leaves);
                        }

                        // ãƒ™ãƒ³ãƒ
                        const benchGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
                        const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                        const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                        bench.position.set(0, 0.1, 2);
                        locationGroup.add(bench);
                        break;

                    case "å›³æ›¸é¤¨":
                        // æœ¬æ£š
                        for(let i = 0; i < 2; i++) {
                            const bookshelfGeometry = new THREE.BoxGeometry(0.3, 3, 2);
                            const bookshelfMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const bookshelf = new THREE.Mesh(bookshelfGeometry, bookshelfMaterial);
                            bookshelf.position.set(
                                i === 0 ? -2 : 2,
                                1.5,
                                0
                            );
                            locationGroup.add(bookshelf);
                        }
                        break;

                    case "ã‚¹ãƒãƒ¼ãƒ„ã‚¸ãƒ ":
                        // ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ãƒã‚·ãƒ³
                        const machineGeometry = new THREE.BoxGeometry(1, 1, 2);
                        const machineMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        const machine = new THREE.Mesh(machineGeometry, machineMaterial);
                        machine.position.set(0, 0.5, 0);
                        locationGroup.add(machine);

                        // ã‚¦ã‚§ã‚¤ãƒˆ
                        const weightGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 8);
                        const weightMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                        for(let i = 0; i < 4; i++) {
                            const weight = new THREE.Mesh(weightGeometry, weightMaterial);
                            weight.position.set(
                                Math.cos(i * Math.PI/2) * 1.5,
                                0.2,
                                Math.sin(i * Math.PI/2) * 1.5
                            );
                            locationGroup.add(weight);
                        }
                        break;

                    case "ç”ºã®åºƒå ´":
                        // å™´æ°´
                        const fountainBaseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.3, 16);
                        const fountainBaseMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        const fountainBase = new THREE.Mesh(fountainBaseGeometry, fountainBaseMaterial);
                        fountainBase.position.set(0, 0.15, 0);
                        locationGroup.add(fountainBase);

                        const fountainCenterGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
                        const fountainCenterMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        const fountainCenter = new THREE.Mesh(fountainCenterGeometry, fountainCenterMaterial);
                        fountainCenter.position.set(0, 0.8, 0);
                        locationGroup.add(fountainCenter);

                        // ãƒ™ãƒ³ãƒ
                        for(let i = 0; i < 4; i++) {
                            const benchGeometry = new THREE.BoxGeometry(2, 0.2, 0.5);
                            const benchMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                            const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                            bench.position.set(
                                Math.cos(i * Math.PI/2) * 3,
                                0.1,
                                Math.sin(i * Math.PI/2) * 3
                            );
                            bench.rotation.y = i * Math.PI/2;
                            locationGroup.add(bench);
                        }
                        break;
                }

                // çœ‹æ¿
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = 'black';
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                context.fillText(loc.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const signMaterial = new THREE.MeshBasicMaterial({ map: texture });
                const signGeometry = new THREE.PlaneGeometry(3, 0.75);
                const signMesh = new THREE.Mesh(signGeometry, signMaterial);
                signMesh.position.set(0, 4.5, 3.1);
                locationGroup.add(signMesh);

                // å ´æ‰€ã®ä½ç½®ã‚’è¨­å®š
                locationGroup.position.set(loc.x, 0, loc.z);
                scene.add(locationGroup);
                
                locations.push({
                    name: loc.name,
                    position: new THREE.Vector3(loc.x, 0, loc.z),
                    mesh: locationGroup,
                    activities: loc.activities,
                    atmosphere: loc.atmosphere
                });
            });

            // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è‡ªå®…ã‚’ä½œæˆ
            agentPersonalities.forEach(agent => {
                const homeGroup = new THREE.Group();
                
                // å®¶ã®åŸºæœ¬æ§‹é€ 
                const houseGeometry = new THREE.BoxGeometry(4, 3, 4);
                const houseMaterial = new THREE.MeshLambertMaterial({ 
                    color: agent.home.color,
                    emissive: agent.home.color,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                house.position.set(0, 1.5, 0);
                house.castShadow = true;
                house.receiveShadow = true;
                homeGroup.add(house);

                // å±‹æ ¹
                const roofGeometry = new THREE.ConeGeometry(3, 2, 4);
                const roofMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    emissive: 0x8B4513,
                    emissiveIntensity: 0.1,
                    transparent: true,
                    opacity: 0.3
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, 4, 0);
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                homeGroup.add(roof);

                // çœ‹æ¿
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.fillRect(0, 0, 256, 64);
                context.fillStyle = 'black';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.fillText(agent.home.name, 128, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const signMaterial = new THREE.MeshBasicMaterial({ map: texture });
                const signGeometry = new THREE.PlaneGeometry(2, 0.5);
                const signMesh = new THREE.Mesh(signGeometry, signMaterial);
                signMesh.position.set(0, 3.5, 2.1);
                homeGroup.add(signMesh);

                // å®¶ã®ä½ç½®ã‚’è¨­å®š
                homeGroup.position.set(agent.home.x, 0, agent.home.z);
                scene.add(homeGroup);
                
                locations.push({
                    name: agent.home.name,
                    position: new THREE.Vector3(agent.home.x, 0, agent.home.z),
                    mesh: homeGroup,
                    activities: ["ä¼‘æ†©ã™ã‚‹", "çœ ã‚‹", "èª­æ›¸ã™ã‚‹"],
                    atmosphere: "é™ã‹ã§è½ã¡ç€ã„ãŸé›°å›²æ°—ã®å®¶",
                    isHome: true,
                    owner: agent.name
                });
            });
        }
        
        // ãƒã‚¦ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        function setupMouseControls() {
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    // ãƒã‚¦ã‚¹ã®ç§»å‹•æ–¹å‘ã¨é€†æ–¹å‘ã«ã‚«ãƒ¡ãƒ©ã‚’ç§»å‹•
                    camera.position.x -= deltaX * 0.1;
                    camera.position.z -= deltaY * 0.1;
                    camera.lookAt(0, 0, 0);
                }
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            document.addEventListener('mousedown', () => {
                isMouseDown = true;
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            document.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
                camera.position.y = Math.max(10, Math.min(50, camera.position.y));
                camera.lookAt(0, 0, 0);
            });
        }
        
        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ä½œæˆ
        function createAgents() {
            agentPersonalities.forEach((data, index) => {
                const agent = new Agent(data, index);
                agents.push(agent);
            });
            updateAgentInfo();
        }
        
        // æ™‚é–“ã‚·ã‚¹ãƒ†ãƒ 
        function updateTime() {
            if (!simulationRunning || simulationPaused) return;
            
            currentTime += timeSpeed;
            if (currentTime >= 24 * 60) {
                currentTime = 0;
            }
            
            const hours = Math.floor(currentTime / 60);
            const minutes = Math.floor(currentTime % 60);
            const timeString = `${hours < 12 ? 'åˆå‰' : 'åˆå¾Œ'} ${hours === 0 ? 12 : hours > 12 ? hours - 12 : hours}:${minutes.toString().padStart(2, '0')}`;
            document.getElementById('time-display').textContent = timeString;
            
            // æ™‚é–“å¸¯ã«ã‚ˆã‚‹ç’°å¢ƒã®å¤‰åŒ–
            updateEnvironment(hours);
        }
        
        function updateEnvironment(hour) {
            // ç©ºã®è‰²ã‚’æ™‚é–“å¸¯ã«å¿œã˜ã¦å¤‰æ›´
            let skyColor;
            if (hour < 6 || hour > 20) {
                skyColor = new THREE.Color(0x1a1a2e); // å¤œ
            } else if (hour < 8 || hour > 18) {
                skyColor = new THREE.Color(0xffa500); // æœå¤•
            } else {
                skyColor = new THREE.Color(0x87CEEB); // æ˜¼
            }
            
            scene.background = skyColor;
            //scene.fog.color = skyColor;
        }
        
        // UIæ›´æ–°
        function updateAgentInfo() {
            const agentsList = document.getElementById('agents-list');
            agentsList.innerHTML = '';
            
            agents.forEach(agent => {
                const agentCard = document.createElement('div');
                agentCard.className = 'agent-card';
                
                // åŸºæœ¬æƒ…å ±
                const nameDiv = document.createElement('div');
                nameDiv.className = 'agent-name';
                nameDiv.innerHTML = `
                    <span class="agent-status status-active"></span>
                    ${agent.name} (${agent.age}æ­³)
                    ${agent.isThinking ? '<span class="thinking-indicator"></span>' : ''}
                `;
                agentCard.appendChild(nameDiv);
                
                // ç¾åœ¨ã®æƒ…å ±
                const infoDiv = document.createElement('div');
                infoDiv.innerHTML = `
                    <div class="agent-info-row">ğŸ“ å ´æ‰€: ${agent.currentLocation.name}</div>
                    <div class="agent-info-row">âš¡ ä½“åŠ›: ${Math.round(agent.energy * 100)}%</div>
                    <div class="agent-info-row">ğŸ˜Š æ°—åˆ†: ${agent.mood}</div>
                `;
                agentCard.appendChild(infoDiv);
                
                // ç¾åœ¨ã®æ€è€ƒ
                if (agent.currentThought) {
                    const thoughtDiv = document.createElement('div');
                    thoughtDiv.className = 'agent-thought';
                    thoughtDiv.textContent = agent.currentThought;
                    agentCard.appendChild(thoughtDiv);
                }
                
                // æœ€è¿‘ã®è¨˜æ†¶
                if (agent.shortTermMemory.length > 0) {
                    const memoryDiv = document.createElement('div');
                    memoryDiv.className = 'agent-memory';
                    memoryDiv.innerHTML = '<strong>æœ€è¿‘ã®è¨˜æ†¶:</strong>';
                    
                    const recentMemories = agent.shortTermMemory.slice(-3);
                    recentMemories.forEach(memory => {
                        const memoryItem = document.createElement('div');
                        memoryItem.className = 'memory-item';
                        memoryItem.textContent = `â€¢ ${memory.event}`;
                        memoryDiv.appendChild(memoryItem);
                    });
                    
                    agentCard.appendChild(memoryDiv);
                }
                
                // é–¢ä¿‚æ€§æƒ…å ±
                const relationshipsDiv = document.createElement('div');
                relationshipsDiv.className = 'relationship-info';
                relationshipsDiv.innerHTML = '<strong>é–¢ä¿‚æ€§:</strong>';
                
                let hasRelationships = false;
                agent.relationships.forEach((rel, name) => {
                    if (rel.interactionCount > 0) {
                        hasRelationships = true;
                        const relItem = document.createElement('div');
                        relItem.className = 'relationship-item';
                        relItem.innerHTML = `
                            <span>${name}:</span>
                            <div class="relationship-bar">
                                <div class="relationship-fill" style="width: ${rel.affinity * 100}%"></div>
                            </div>
                        `;
                        relationshipsDiv.appendChild(relItem);
                    }
                });
                
                if (hasRelationships) {
                    agentCard.appendChild(relationshipsDiv);
                }
                
                agentsList.appendChild(agentCard);
            });
        }
        
        // ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 
        function addLog(message, type = 'info', details = null) {
            const logPanel = document.getElementById('activity-log');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            
            const time = new Date();
            const timeString = time.toLocaleTimeString('ja-JP', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            let logContent = `<strong>${timeString}</strong> ${message}`;
            
            // è©³ç´°æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯æŠ˜ã‚ŠãŸãŸã¿å¯èƒ½ãªã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ã—ã¦è¡¨ç¤º
            if (details) {
                const detailsId = `details-${Date.now()}`;
                logContent += `
                    <div class="log-details-toggle" onclick="toggleDetails('${detailsId}')">
                        <span class="toggle-icon">â–¼</span> è©³ç´°ã‚’è¦‹ã‚‹
                    </div>
                    <div id="${detailsId}" class="log-details" style="display: none;">
                        ${details}
                    </div>
                `;
            }
            
            logEntry.innerHTML = logContent;
            logPanel.insertBefore(logEntry, logPanel.firstChild);
            
            // æœ€å¤§50ä»¶ã®ãƒ­ã‚°ã‚’ä¿æŒ
            while (logPanel.children.length > 50) {
                logPanel.removeChild(logPanel.lastChild);
            }
        }
        
        // ãƒ­ã‚°ã®è©³ç´°è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleDetails(detailsId) {
            const details = document.getElementById(detailsId);
            const toggle = details.previousElementSibling;
            const icon = toggle.querySelector('.toggle-icon');
            
            if (details.style.display === 'none') {
                details.style.display = 'block';
                icon.textContent = 'â–²';
                toggle.querySelector('span:not(.toggle-icon)').textContent = ' è©³ç´°ã‚’éš ã™';
            } else {
                details.style.display = 'none';
                icon.textContent = 'â–¼';
                toggle.querySelector('span:not(.toggle-icon)').textContent = ' è©³ç´°ã‚’è¦‹ã‚‹';
            }
        }
        
        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¡Œå‹•ãƒ­ã‚°ã‚’è¨˜éŒ²
        function logAgentAction(agent, action, details = null) {
            const actionTypes = {
                'move': 'ğŸš¶ ç§»å‹•',
                'interact': 'ğŸ’¬ ä¼šè©±',
                'activity': 'ğŸ¯ æ´»å‹•',
                'think': 'ğŸ’­ æ€è€ƒ'
            };

            const actionType = actionTypes[action] || action;
            const message = `<span class="agent-name">${agent.name}</span>: ${actionType}`;
            
            if (!details) {
                details = `
                    <div class="log-detail-section">
                        <h4>ç¾åœ¨ã®çŠ¶æ…‹</h4>
                        <p>å ´æ‰€: ${agent.currentLocation.name}</p>
                        <p>ä½“åŠ›: ${Math.round(agent.energy * 100)}%</p>
                        <p>æ°—åˆ†: ${agent.calculateMood()}</p>
                    </div>
                `;
            }
            
            addLog(message, action, details);
        }

        // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®é–¢ä¿‚æ€§ãƒ­ã‚°ã‚’è¨˜éŒ²
        function logRelationshipChange(agent1, agent2, changeType, details = null) {
            const relationship = agent1.relationships.get(agent2.name);
            const message = `
                <span class="agent-name">${agent1.name}</span> ã¨ 
                <span class="agent-name">${agent2.name}</span> ã®é–¢ä¿‚æ€§ãŒå¤‰åŒ–
            `;
            
            if (!details) {
                details = `
                    <div class="log-detail-section">
                        <h4>é–¢ä¿‚æ€§ã®è©³ç´°</h4>
                        <p>è¦ªå¯†åº¦: ${Math.round(relationship.familiarity * 100)}%</p>
                        <p>å¥½æ„Ÿåº¦: ${Math.round(relationship.affinity * 100)}%</p>
                        <p>äº¤æµå›æ•°: ${relationship.interactionCount}å›</p>
                        <p>æœ€å¾Œã®äº¤æµ: ${relationship.lastInteraction ? relationship.lastInteraction.toLocaleString() : 'ãªã—'}</p>
                    </div>
                `;
            }
            
            addLog(message, 'relationship', details);
        }
        
        // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡
        function startSimulation() {
            apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert('OpenAI APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            simulationRunning = true;
            document.getElementById('pauseBtn').disabled = false;
            
            // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ä½œæˆ
            createAgents();
            
            addLog('<span style="color: #4CAF50;">ğŸ¬ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹</span>');
        }
        
        function pauseSimulation() {
            simulationPaused = !simulationPaused;
            document.getElementById('pauseBtn').textContent = simulationPaused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
            
            if (simulationPaused) {
                addLog('<span style="color: #FFC107;">â¸ï¸ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸€æ™‚åœæ­¢</span>');
            } else {
                addLog('<span style="color: #4CAF50;">â–¶ï¸ ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å†é–‹</span>');
            }
        }
        
        function setTimeSpeed() {
            const speeds = [1, 2, 5, 10];
            const currentIndex = speeds.indexOf(timeSpeed);
            const nextIndex = (currentIndex + 1) % speeds.length;
            timeSpeed = speeds[nextIndex];
            document.getElementById('speed').textContent = `${timeSpeed}x`;
        }
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            // æ™‚é–“ã®æ›´æ–°
            updateTime();
            
            // ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®æ›´æ–°
            if (agents.length > 0) {
                agents.forEach(agent => {
                    agent.update(deltaTime);
                });
                
                // UIæ›´æ–°ï¼ˆ1ç§’ã”ã¨ï¼‰
                if (Math.floor(clock.getElapsedTime()) % 1 === 0) {
                    updateAgentInfo();
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // åˆæœŸåŒ–
        init();
    </script>
</body>
</html>